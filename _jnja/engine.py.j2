import hashlib
import re

import base64
import time
import hmac

import logging
import json
from collections import defaultdict
from jinja2 import Environment, FileSystemLoader
from pygments import highlight, lexers, formatters
from packaging import version
import pandas as pd
from pandas.io.json import json_normalize #package for flattening json in pandas df
from tabulate import tabulate
import click
import htmlmin
import requests

log = logging.getLogger(__name__)

def engine(elm, **kwargs):
    """This is common engine for all commands"""

    logging.debug('passed kwargs: %s', kwargs)
    logging.info('elm.command: %s', elm.command)
    logging.info('elm.path: %s', elm.path)
    logging.info('elm.outfile: %s', elm.outfile)
    logging.info('elm.outfmt: %s', elm.outfmt)

    # ben magic, throw away False and Empty flags (also zeros!)
    flags = {k: v for k, v in kwargs.items() if v}
    logging.debug('passed flags: %s', flags)

    #set size to max (1000) if size is 0
    #0 values are removed by ben magic above
    if 'size' in kwargs and kwargs['size'] == 0:
        logging.debug('kwargs[\'size\']: %s', kwargs['size'])
        logging.debug('size set to 0, changing to 1000 for max size allowed by api')
        flags['size'] = 1000
        logging.debug('kwargs[\'size\']: %s', kwargs['size'])

    #Request Info
    httpVerb ='GET'
    logging.debug('httpVerb: %s', httpVerb)

    #construct path based on passed attributes (path values)
    # find everything between {} and replace in path with value
    attributes = re.findall('\{([A-Za-z0-9_]+?)\}',elm.path)
    logging.debug('attributes: %s', attributes)

    #todo: what does this do?
    for attribute in attributes:
        logging.debug('ins "%s" value "%s" into %s', attribute, flags[attribute], elm.path)
        elm.path = elm.path.replace("{" + attribute + "}", str(flags[attribute]))

        # remove the attribute from flags
        logging.debug('del "%s" from flags', attribute)
        del flags[attribute]

    #todo: check for any remaining attributes by looking for {} in elm.path
    #logging.warning('not all attributes replaced in path: %s', elm.path)

    logging.debug('elm.path attributes: %s', elm.path)
    logging.debug('remaining flags: %s', flags)

    resourcePath = elm.path
    logging.debug('resourcePath: %s', resourcePath)

    #construct query
    queryParams = '?v=2'

    #turn flags into queryParams key values
    for flag in flags:
        logging.debug('flag: %s', flag)
        logging.debug('flags[flag]: %s', flags[flag])
        queryParams += '&' + flag + '=' + str(flags[flag])

    logging.debug('queryParams: %s', queryParams)

    data = ''
    logging.debug('data: %s', data)

    #Construct URL
    url = 'https://'+ elm.account_name +'.logicmonitor.com/santaba/rest' + resourcePath + queryParams
    logging.debug('url: %s', url)

    #Get current time in milliseconds
    epoch = str(int(time.time() * 1000))
    logging.debug('epoch: %s', epoch)

    #Concatenate Request details
    requestVars = httpVerb + epoch + data + resourcePath
    logging.debug('requestVars: %s', requestVars)

    #Construct signature
    hmac1 = hmac.new(elm.access_key.encode(),msg=requestVars.encode(),digestmod=hashlib.sha256).hexdigest()
    signature = base64.b64encode(hmac1.encode())

    #Construct headers
    auth = 'LMv1 ' + elm.access_id + ':' + signature.decode() + ':' + epoch
    # dont show this as it has the api auth details
    #logging.info('auth: %s', auth)
    headers = {'Content-Type':'application/json','Authorization':auth}
    # dont show this as it has the api auth details
    #logging.info('headers: %s', headers)

    #Make request
    try:
        response = requests.get(url, data=data, headers=headers)
        logging.debug('response.headers.X-Rate-Limit-Limit: %s', response.headers['X-Rate-Limit-Limit'])
        logging.debug('response.headers.X-Rate-Limit-Remaining: %s', response.headers['X-Rate-Limit-Remaining'])
        logging.debug('response.headers.X-Rate-Limit-Window: %s', response.headers['X-Rate-Limit-Window'])
        response.raise_for_status()
    except:
        click.secho('An error occured', fg='red', err=True)
        click.secho(elm.command, fg='red', err=True)
        click.secho(elm.path, fg='red', err=True)
        click.secho(flags, fg='red', err=True)

    logging.info('response.status_code: %s', response.status_code)
    logging.info('response.content: %s', response.content)

    # do I need this or is it covered by above raise for status?
    if not response:
        logging.warning('not 200 status code: %s', response.status_code)
        click.secho('Warning: not 200 status code', fg='yellow', err=True)

    # where should this go, do we need it?
    response.encoding = 'utf-8'

    if elm.export:
        logging.debug('elm.export: %s', elm.export)
        logging.debug('elm.config_file: %s', elm.config_file)
        logging.debug('elm.path: %s', elm.path)
        logging.debug('elm.flags: %s', elm.flags)
        export(elm.export, elm.config_file, elm.command, elm.path, flags)

    #obj = response.content
    obj = response.json()
    #obj = response.content.decode('utf-8')

    if 'items' not in obj:
        logging.debug('items not in obj, setting to defaults')
        obj = {
            "total": 1,
            "items": [obj],
            "searchId": None,
            "isMin": False
        }

    logging.info('total records: %s', obj.get('total', None))
    logging.debug('searchId: %s', obj.get('searchId', None))
    logging.debug('isMin: %s', obj.get('isMin', None))
    logging.debug('obj: %s', obj)

    if 'total' in flags:
        logging.debug('total is a flag, showing total instead')
        click.echo(obj['total'])
    elif 'count' in flags:
        logging.debug('count is a flag, showing count instead')
        click.echo(len(obj['items']))
    else:
        output(obj['items'], elm.command, elm.outfile, elm.outfmt)

        #give a warning if there are more records not shown
        if 'size' in flags and obj['total'] > flags['size']:
            click.secho('Warning: size limit is less than total records,'
                        ' there is data you are not seeing.',
                        fg='yellow', err=True)

def output(items, command, outfile='-', outfmt='json'):
    df = pd.DataFrame(items)
    pd.set_option('display.max_columns', 0)
    pd.set_option('display.max_colwidth', 0)

    if not df.empty:
        #convert any columns with an subdict

        logging.debug('format: %s', outfmt)
        if outfmt == 'csv':
            output = df.to_csv(index=False)
        elif outfmt == 'html':
            output = htmlmin.minify(df.to_html(index=False, render_links=True, escape=False), remove_empty_space=True)
        elif outfmt == 'prettyhtml':
            output = highlight(df.to_html(index=False, render_links=True, escape=False), lexers.HtmlLexer(), formatters.TerminalFormatter())
        elif outfmt == 'jira':
            output = df.to_markdown(index=False,tablefmt="jira")
        elif outfmt == 'json':
            output = json.dumps({command: items})
        elif outfmt == 'prettyjson':
            formatted_json=json.dumps({command: items}, sort_keys=True, indent=2)
            colorful_json = highlight(formatted_json, lexers.JsonLexer(), formatters.TerminalFormatter())
            output = colorful_json.rstrip("\n")
        elif outfmt == 'latex':
            output = df.to_latex(index=False)
        elif outfmt == 'md':
            output = df.to_markdown(index=False)
        elif outfmt == 'tab':
            output = tabulate(df, showindex=False, headers=df.columns)
        elif outfmt == 'raw':
            output = items
        else:
            # fail to txt
            output = df.to_string(index=False)

        output_file = click.open_file(outfile, mode='w')
        click.echo(output, file=output_file)
    else:
        click.secho('Warning: no data found', fg='yellow', err=True)

def export(export, config_file, command, path, flags=""):
    '''export python query to file'''
    file_loader = FileSystemLoader('elm')
    env = Environment(loader=file_loader)
    template = env.get_template('save_query.py.j2')
    output = template.render(config_file=config_file, command=command, path=path, flags=flags)
    export.write(output)

def validate_filter(ctx, param, value):
    if value:
        try:
            field, operator, value = re.split(r'(>\:|<\:|>|<|\!|\:|~|\!~)', value, 1)
            logging.debug('field: %s', field)
            logging.debug('operator: %s', operator)
            logging.debug('value: %s', value)
            #filter needs quotes around the value to work for strings
            #ints are not unaffected, so do it for everything
            value = '"' + value + '"'
            logging.debug('value: %s', value)
            return field + operator + value
        except ValueError:
            raise click.BadParameter("format must be 'FIELD[>:,<:,>,<,!,:,~,!~]VALUE'")

